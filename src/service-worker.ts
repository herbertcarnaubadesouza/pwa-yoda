/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */
/* eslint-disable import/first */

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { createHandlerBoundToURL, precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process.
precacheAndRoute(self.__WB_MANIFEST);

// Firebase setup
importScripts('https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js');
importScripts('https://www.gstatic.com/firebasejs/8.10.0/firebase-messaging.js');

declare const firebase: any;

const firebaseConfig = {
  apiKey: "AIzaSyB0YLVsu24Ge4s3Kh83qPaWHuSd0kewkdM",
  authDomain: "service-pwa-a0b8a.firebaseapp.com",
  projectId: "service-pwa-a0b8a",
  storageBucket: "service-pwa-a0b8a.appspot.com",
  messagingSenderId: "864048105713",
  appId: "1:864048105713:web:86495c6b0582557be6c150",
  measurementId: "G-DCNTXD2GR7"
};

firebase.initializeApp(firebaseConfig);

const messaging = firebase.messaging();

messaging.getToken({ vapidKey: 'BJ3mvEAQ6SWJ_2XsIITHNQybkbR4VMBf9FL3UXWWplWzkKHLhSvaCrQuKA8uQHn_lbq7OsGCzItPwVVCI-_p_y0' }).then((currentToken: any) => {
  if (currentToken) {
    console.log('Token de mensagem: ', currentToken);
  } else {
    console.log('Não é possível obter o token do Firebase Messaging');
  }
});

// Notification setup
setInterval(() => {
  self.registration.showNotification('Título da Notificação', {
    body: 'Conteúdo da Notificação',
    icon: '/caminho/para/icone.png'
  });
}, 10000); // 10000 ms = 10 segundos

const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

self.addEventListener('message', (event) => {
  console.log(event.data.text());
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

self.addEventListener('install', function (event) {
  self.skipWaiting();
});

self.addEventListener('activate', function (event) {
  event.waitUntil(self.clients.claim());
});

self.addEventListener('push', function (event) {
  Notification.requestPermission().then((permission) => {
    if (permission === 'granted') {
      console.log('Notificação permitida.');

      self.registration.showNotification('Título da Notificação', {
        body: 'Conteúdo da Notificação',
        icon: '/caminho/para/icone.png'
      });
    } else if (permission === 'denied') {
      console.log('O usuário negou a permissão de notificação.');
    } else {
      console.log('O usuário dispensou a permissão de notificação.');
    }
  });
});
